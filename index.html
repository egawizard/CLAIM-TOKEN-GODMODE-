// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

/**
 * @title GODMODE Token
 * @dev ERC-20 Token for Farcaster Mini App
 * 
 * Tokenomics:
 * - Total Supply: 1,000,000,000 (1B) tokens
 * - Mintable Supply: 900,000,000 (900M) tokens
 * - Treasury Reserve: 100,000,000 (100M) tokens
 * - Tokens per Mint: 45,000 tokens
 * - Total Mints Available: 20,000
 * - Mint Price: 0.00012 ETH (Base Mainnet)
 * - Max Mints per User: 50
 */
contract GODMODE is ERC20, ReentrancyGuard {
    // Constants
    uint256 public constant TOTAL_SUPPLY = 1_000_000_000 * 10**18; // 1 billion tokens
    uint256 public constant MINTABLE_SUPPLY = 900_000_000 * 10**18; // 900 million tokens
    uint256 public constant TREASURY_RESERVE = 100_000_000 * 10**18; // 100 million tokens
    uint256 public constant TOKENS_PER_MINT = 45_000 * 10**18; // 45,000 tokens per mint
    uint256 public constant TOTAL_MINTS_AVAILABLE = 20_000; // 20,000 total mints
    uint256 public constant MINT_PRICE = 0.00012 ether; // 0.00012 ETH
    uint256 public constant MAX_MINTS_PER_USER = 50; // Maximum 50 mints per user

    // Treasury wallet address
    address public immutable treasury;
    
    // Owner address for emergency functions
    address public immutable owner;

    // Minting tracking
    uint256 public totalMintCount;
    mapping(address => uint256) public userMintCount;

    // Events
    event TokensMinted(address indexed user, uint256 amount, uint256 mintNumber);
    event TreasuryWithdrawal(address indexed treasury, uint256 amount);

    // Modifier
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }

    /**
     * @dev Constructor - Deploys the GODMODE token
     * Automatically mints 100M treasury reserve to specified treasury address
     */
    constructor() ERC20("GODMODE", "GODMODE") {
        // Set deployer as owner
        owner = msg.sender;
        
        // Treasury address for Base Mainnet
        treasury = 0xb9AE3cDFA1ca0484E24E465Df7F49aDBd175B642;
        
        // Mint treasury reserve directly to treasury wallet
        _mint(treasury, TREASURY_RESERVE);
    }

    /**
     * @dev Mint tokens by paying the mint price
     * @param mintCount Number of times to mint (each mint = 45,000 tokens)
     */
    function mint(uint256 mintCount) external payable nonReentrant {
        require(mintCount > 0, "Mint count must be greater than 0");
        require(totalMintCount + mintCount <= TOTAL_MINTS_AVAILABLE, "Exceeds total mint limit");
        require(userMintCount[msg.sender] + mintCount <= MAX_MINTS_PER_USER, "Exceeds user mint limit");
        require(msg.value == MINT_PRICE * mintCount, "Incorrect ETH amount");

        uint256 tokensToMint = TOKENS_PER_MINT * mintCount;
        
        // Update counters
        totalMintCount += mintCount;
        userMintCount[msg.sender] += mintCount;

        // Mint tokens to user
        _mint(msg.sender, tokensToMint);

        // Transfer ETH to treasury
        (bool success, ) = treasury.call{value: msg.value}("");
        require(success, "ETH transfer to treasury failed");

        emit TokensMinted(msg.sender, tokensToMint, mintCount);
    }

    /**
     * @dev Get remaining mints available globally
     */
    function remainingMints() external view returns (uint256) {
        return TOTAL_MINTS_AVAILABLE - totalMintCount;
    }

    /**
     * @dev Get remaining mints available for a specific user
     */
    function remainingMintsForUser(address user) external view returns (uint256) {
        return MAX_MINTS_PER_USER - userMintCount[user];
    }

    /**
     * @dev Get total tokens minted (excluding treasury reserve)
     */
    function totalMinted() external view returns (uint256) {
        return totalMintCount * TOKENS_PER_MINT;
    }

    /**
     * @dev Emergency withdrawal function (only owner, for stuck funds)
     */
    function emergencyWithdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No balance to withdraw");
        
        (bool success, ) = treasury.call{value: balance}("");
        require(success, "Emergency withdrawal failed");
        
        emit TreasuryWithdrawal(treasury, balance);
    }

    /**
     * @dev Prevent accidental ETH sends
     */
    receive() external payable {
        revert("Use mint() function to mint tokens");
    }
}
