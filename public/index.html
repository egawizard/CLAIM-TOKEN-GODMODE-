<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CLAIM TOKEN $GODMODE — Free Mint</title>

  <!-- Mini App embed/meta for social preview (used by hosts) -->
  <meta name="fc:miniapp" content='{"title":"CLAIM TOKEN $GODMODE FREE MINT","image":"https://claim-token-godmode.vercel.app/assets/cover.png","action":"Open"}' />

  <style>
    /* Luxurious dark theme, compact and modern. Tweak to taste. */
    :root {
      --bg: #020617;
      --card: linear-gradient(135deg,#08102a,#0b1226);
      --accent: linear-gradient(90deg,#a78bfa,#60a5fa);
      --glass: rgba(255,255,255,0.03);
      --muted: #9aa4b2;
    }
    html,body{height:100%; margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    body{background: radial-gradient(circle at 10% 20%, rgba(96,165,250,0.06), transparent 8%), var(--bg); color:#e6eef8; display:flex; align-items:center; justify-content:center; padding:24px;}
    .card{width:420px; background:var(--card); border-radius:18px; padding:20px; box-shadow:0 10px 40px rgba(3,7,18,0.6); border:1px solid rgba(255,255,255,0.03)}
    h1{margin:0 0 6px; font-size:20px; letter-spacing:0.6px}
    p.lead{margin:0 0 18px; font-size:13px; color:var(--muted)}
    .bar-wrap{background:rgba(255,255,255,0.04); height:12px; border-radius:999px; overflow:hidden; margin:10px 0 18px;}
    .bar{height:100%; width:0%; background: linear-gradient(90deg,#a78bfa,#60a5fa); transition: width 600ms cubic-bezier(.2,.9,.2,1);}
    .controls{display:flex; gap:10px; align-items:center;}
    input[type=number]{width:100px;padding:10px;border-radius:10px;border:none;background:var(--glass); color:inherit;}
    button{padding:10px 14px;border-radius:10px;border:none;background:linear-gradient(90deg,#7c3aed,#2563eb); color:white;font-weight:600;cursor:pointer}
    button:disabled{opacity:.5; cursor:not-allowed}
    .small{font-size:12px;color:var(--muted)}
    .info-row{display:flex;justify-content:space-between;align-items:center;margin-top:12px}
    .success{background:linear-gradient(90deg,#10b981,#06b6d4); padding:8px;border-radius:8px;color:#04111a}
  </style>
</head>
<body>
  <div class="card" id="app">
    <h1>CLAIM TOKEN <span style="color:#60a5fa">$GODMODE</span> — FREE MINT</h1>
    <p class="lead">Limited availability — Max <strong id="maxPerUser">50</strong> claims per user. Small fee required to cover gas; app still called “FREE MINT”.</p>

    <div>
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="small">Total Mint Progress</div>
        <div class="small" id="progressText">-- / --</div>
      </div>
      <div class="bar-wrap"><div class="bar" id="progressBar"></div></div>
    </div>

    <div style="margin-top:6px" id="walletStatus"><span class="small">Not connected</span></div>

    <div style="margin-top:14px" class="controls">
      <input type="number" id="mintCount" value="1" min="1" max="50" />
      <button id="mintBtn">Mint</button>
    </div>

    <div class="info-row small" style="margin-top:10px">
      <div>Price (per mint)</div>
      <div id="priceText">0.00012 ETH</div>
    </div>

    <div id="message" style="margin-top:12px"></div>
  </div>

  <script type="module">
    // Imports via ESM CDN
    import sdk from 'https://unpkg.com/@farcaster/miniapp-sdk?module';
    import { ethers } from 'https://cdn.jsdelivr.net/npm/ethers@6.9.2/dist/ethers.esm.min.js';

    // --------------------------
    // Config (customize here)
    // --------------------------
    const CONTRACT_ADDRESS = '0xfe0b0148A535ab66F83e19756A20A0b9fCAF1305';
    const ABI = [
      "function mint(uint256) payable",
      "function remainingMints() view returns (uint256)",
      "function remainingMintsForUser(address) view returns (uint256)",
      "function totalMinted() view returns (uint256)",
      "function TOTAL_MINTS_AVAILABLE() view returns (uint256)",
      "function MAX_MINTS_PER_USER() view returns (uint256)"
    ];
    const MINT_PRICE_ETH = '0.00012'; // display reference (contract will check actual msg.value)

    // UI refs
    const mintBtn = document.getElementById('mintBtn');
    const mintCountEl = document.getElementById('mintCount');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const walletStatus = document.getElementById('walletStatus');
    const message = document.getElementById('message');
    const maxPerUserEl = document.getElementById('maxPerUser');

    let provider, signer, contract, userAddress;
    let totalMintsAvailable = 20000; // fallback. we will read from chain.

    // Helper to show messages
    function showMsg(html, isError=false){
      message.innerHTML = '<div style="padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);color:'+(isError? '#ffb4b4':'#bff4d6')+'">'+html+'</div>';
    }

    // Step 1: tell host we are ready (removes splash screens)
    sdk.actions?.ready?.();

    // Step 2: attempt to get provider and signer (auto-connect)
    async function initWallet() {
      try {
        const ethProvider = await sdk.wallet.getEthereumProvider();
        if (!ethProvider) {
          walletStatus.innerHTML = '<span class="small">No wallet provider available</span>';
          return;
        }
        // Ethers wraps EIP-1193 provider with BrowserProvider
        provider = new ethers.BrowserProvider(ethProvider);
        signer = await provider.getSigner();
        try {
          userAddress = await signer.getAddress();
        } catch (e) {
          userAddress = null;
        }

        walletStatus.innerHTML = userAddress
          ? `<div style="font-weight:600">${userAddress.slice(0,6)}…${userAddress.slice(-4)}</div><div class="small">Connected (Base)</div>`
          : `<div class="small">Wallet available — not connected</div>`;
        contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
      } catch (err) {
        console.error('initWallet error', err);
        walletStatus.innerHTML = '<div class="small">Wallet init error</div>';
      }
    }

    async function refreshProgressAndLimits() {
      try {
        if (!contract) return;
        // remainingMints() returns remaining global mints
        const remaining = await contract.remainingMints();
        const remainingNum = Number(ethers.toBigInt(remaining).toString());
        // try to fetch TOTAL_MINTS_AVAILABLE constant
        let totalAvailable;
        try {
          const t = await contract.TOTAL_MINTS_AVAILABLE();
          totalAvailable = Number(ethers.toBigInt(t).toString());
        } catch {
          totalAvailable = totalMintsAvailable;
        }
        const used = totalAvailable - remainingNum;
        const pct = Math.min(100, Math.round((used / totalAvailable) * 100));
        progressBar.style.width = pct + '%';
        progressText.textContent = `${used} / ${totalAvailable}`;

        // per-user remaining
        if (userAddress) {
          const remForUser = await contract.remainingMintsForUser(userAddress);
          const remUserNum = Number(ethers.toBigInt(remForUser).toString());
          maxPerUserEl.textContent = remUserNum; // update UI to show remaining
          mintCountEl.max = Math.max(1, remUserNum);
          if (remUserNum === 0) {
            mintBtn.disabled = true;
            showMsg('You have reached the per-user mint limit.', true);
          } else {
            mintBtn.disabled = false;
          }
        }
      } catch (e) {
        console.error('refresh error', e);
      }
    }

    async function handleMint() {
      if (!contract || !signer) {
        showMsg('Please open this Mini App inside a Farcaster client with an attached wallet.', true);
        return;
      }

      const count = Number(mintCountEl.value || 1);
      if (!Number.isInteger(count) || count <= 0) { showMsg('Invalid mint count', true); return; }
      // calculate value
      const value = ethers.parseEther(String(parseFloat(MINT_PRICE_ETH) * count));
      mintBtn.disabled = true;
      showMsg('Preparing transaction...');

      try {
        // call contract.mint(count, { value })
        const tx = await contract.connect(signer).mint(count, { value });
        showMsg('Transaction sent — waiting for confirmation...');
        await tx.wait();
        showMsg('Success! Tokens claimed. Crafting a cast...', false);

        // After successful mint, refresh progress
        await refreshProgressAndLimits();

        // Auto-cast (post) to Farcaster using SDK action
        try {
          const castText = `I just claimed my $GODMODE tokens — FREE MINT! Claim yours: https://claim-token-godmode.vercel.app #GODMODE`;
          await sdk.actions.composeCast({ text: castText });
          showMsg('Mint successful — a cast was posted to your feed.');
        } catch (castErr) {
          console.warn('composeCast failed', castErr);
          showMsg('Mint succeeded. Could not autocast automatically — try posting manually.', false);
        }
      } catch (err) {
        console.error(err);
        showMsg('Transaction failed or rejected. See console for details.', true);
      } finally {
        mintBtn.disabled = false;
      }
    }

    // Wire up events
    mintBtn.addEventListener('click', handleMint);

    // Init flow
    await initWallet();
    // After wallet init, create a readonly contract if signer not available (fallback)
    if (!contract && typeof window.ethereum !== 'undefined') {
      const fallbackProvider = new ethers.WebSocketProvider('https://mainnet.base.org'); // optional fallback; replace if you have RPC
      contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, fallbackProvider);
    }
    // initial refresh
    await refreshProgressAndLimits();

    // Poll progress every 20s (keeps progress bar up-to-date)
    setInterval(refreshProgressAndLimits, 20000);
  </script>
</body>
</html>
